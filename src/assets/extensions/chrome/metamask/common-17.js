LavaPack.loadBundle([[999,{"./errors":1e3,"./modules/Domains":1001,"./modules/EIP712":1002,"./services/ledger":1009,"./utils":1012,"@ethersproject/transactions":856,"@ledgerhq/logs":1018,"bignumber.js":1013,buffer:4474},function(){with(this.scopeTerminator)with(this.globalThis)return function(){"use strict";return function(t,e,r){(function(e){(function(){var n=Object.create?function(t,e,r,n){n===undefined&&(n=r);var o=Object.getOwnPropertyDescriptor(e,r);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,o)}:function(t,e,r,n){n===undefined&&(n=r),t[n]=e[r]},o=function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)},i=function(t,e,r,n){return new(r||(r=Promise))(function(o,i){function s(t){try{l(n.next(t))}catch(t){i(t)}}function a(t){try{l(n.throw(t))}catch(t){i(t)}}function l(t){var e;t.done?o(t.value):(e=t.value,e instanceof r?e:new r(function(t){t(e)})).then(s,a)}l((n=n.apply(t,e||[])).next())})},s=function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(r,"__esModule",{value:!0}),r.ledgerService=void 0;const a=t("@ledgerhq/logs"),l=t("bignumber.js"),h=t("@ethersproject/transactions"),c=t("./errors"),u=t("./modules/EIP712"),g=t("./modules/Domains"),d=s(t("./services/ledger"));r.ledgerService=d.default;const f=t("./utils");o(t("./utils"),r);const p={eth:1,erc20:2,erc721:3,erc20mintable:4,erc721mintable:5},S=t=>t&&27264===t.statusCode?new c.EthAppPleaseEnableContractData("Please enable Blind signing or Contract data in the Ethereum app Settings"):t;r.default=class{setLoadConfig(t){this.loadConfig=t}constructor(t,e="w0w",r={}){this.transport=t,this.loadConfig=r,t.decorateAppAPIMethods(this,["getAddress","signTransaction","signPersonalMessage","getAppConfiguration","signEIP712Message","signEIP712HashedMessage","starkGetPublicKey","starkSignOrder","starkSignOrder_v2","starkSignTransfer","starkSignTransfer_v2","starkProvideQuantum","starkProvideQuantum_v2","starkUnsafeSign","eth2GetPublicKey","eth2SetWithdrawalIndex","getEIP1024PublicEncryptionKey","getEIP1024SharedSecret"],e)}getAddress(t,r,n,o){const i=(0,f.splitPath)(t);let s=e.alloc(1+4*i.length);if(s[0]=i.length,i.forEach((t,e)=>{s.writeUInt32BE(t,1+4*e)}),o){const t=e.alloc(8,0),r=e.from((0,f.padHexString)(new l.BigNumber(o).toString(16)),"hex");t.write(r.toString("hex"),t.length-r.length,"hex"),s=e.concat([s,t])}return this.transport.send(224,2,r?1:0,n?1:0,s).then(t=>{const e=t[0],r=t[1+e];return{publicKey:t.slice(1,1+e).toString("hex"),address:"0x"+t.slice(1+e+1,1+e+1+r).toString("ascii"),chainCode:n?t.slice(1+e+1+r,1+e+1+r+32).toString("hex"):undefined}})}signTransaction(t,r,n){return i(this,void 0,void 0,function*(){let o;if(function(t){t[t.CLA=224]="CLA",t[t.INS=4]="INS",t[t.P1_FIRST_CHUNK=0]="P1_FIRST_CHUNK",t[t.P1_FOLLOWING_CHUNK=128]="P1_FOLLOWING_CHUNK",t[t.P2=0]="P2"}(o||(o={})),n===undefined&&(console.warn("hw-app-eth: signTransaction(path, rawTxHex, resolution): please provide the 'resolution' parameter. See https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-eth/README.md â€“ the previous signature is deprecated and providing the 3rd 'resolution' parameter explicitly will become mandatory so you have the control on the resolution and the fallback mecanism (e.g. fallback to blind signing or not).// Possible solution:\n + import { ledgerService } from '@ledgerhq/hw-app-eth';\n + const resolution = await ledgerService.resolveTransaction(rawTxHex);"),n=yield d.default.resolveTransaction(r,this.loadConfig,{externalPlugins:!0,erc20:!0,uniswapV3:!1}).catch(t=>(console.warn("an error occurred in resolveTransaction => fallback to blind signing: "+String(t)),null))),n){for(const t of n.domains)yield(0,g.domainResolutionFlow)(this,t).catch(e=>{(0,a.log)("error","domainResolutionFlow failed",{domainDescriptor:t,error:e})});for(const t of n.plugin)yield this.setPlugin(t);for(const{payload:t,signature:e}of n.externalPlugin)yield this.setExternalPlugin(t,e);for(const t of n.nfts)yield this.provideNFTInformation(t);for(const t of n.erc20Tokens)yield this.provideERC20TokenInformation(t)}const i=e.from(r,"hex"),s=(0,h.parse)(`0x${i.toString("hex")}`),c=new l.BigNumber(s.chainId),u=(0,f.splitPath)(t),p=e.alloc(1+4*u.length);p[0]=u.length,u.forEach((t,e)=>{p.writeUInt32BE(t,1+4*e)});const y=(0,f.safeChunkTransaction)(i,p,s.type);let w;for(const t of y){const e=t===y[0];w=yield this.transport.send(o.CLA,o.INS,e?o.P1_FIRST_CHUNK:o.P1_FOLLOWING_CHUNK,o.P2,t).catch(t=>{throw S(t)})}return{v:(0,f.getV)(w[0],c,s.type),r:w.subarray(1,33).toString("hex"),s:w.subarray(33,65).toString("hex")}})}clearSignTransaction(t,e,r){return i(this,arguments,void 0,function*(t,e,r,n=!1){const o=yield d.default.resolveTransaction(e,this.loadConfig,r).catch(t=>{if(console.warn("an error occurred in resolveTransaction => fallback to blind signing: "+String(t)),n)throw t;return null});return this.signTransaction(t,e,o)})}getAppConfiguration(){return this.transport.send(224,6,0,0).then(t=>({arbitraryDataEnabled:1&t[0],erc20ProvisioningNecessary:2&t[0],starkEnabled:4&t[0],starkv2Supported:8&t[0],version:t[1]+"."+t[2]+"."+t[3]}))}signPersonalMessage(t,r){return i(this,void 0,void 0,function*(){const n=(0,f.splitPath)(t);let o=0;const i=e.from(r,"hex");let s;for(;o!==i.length;){const t=0===o?149-4*n.length-4:150,r=o+t>i.length?i.length-o:t,a=e.alloc(0===o?1+4*n.length+4+r:r);0===o?(a[0]=n.length,n.forEach((t,e)=>{a.writeUInt32BE(t,1+4*e)}),a.writeUInt32BE(i.length,1+4*n.length),i.copy(a,1+4*n.length+4,o,o+r)):i.copy(a,0,o,o+r),s=yield this.transport.send(224,8,0===o?0:128,0,a),o+=r}return{v:s[0],r:s.slice(1,33).toString("hex"),s:s.slice(33,65).toString("hex")}})}signEIP712HashedMessage(t,e,r){return(0,u.signEIP712HashedMessage)(this.transport,t,e,r)}signEIP712Message(t,e){return i(this,arguments,void 0,function*(t,e,r=!1){return(0,u.signEIP712Message)(this.transport,t,e,r,this.loadConfig)})}getChallenge(){return i(this,void 0,void 0,function*(){let t;return function(t){t[t.CLA=224]="CLA",t[t.INS=32]="INS",t[t.P1=0]="P1",t[t.P2=0]="P2",t[t.LC=0]="LC"}(t||(t={})),this.transport.send(t.CLA,t.INS,t.P1,t.P2).then(t=>{const[,e,r]=new RegExp("(.*)(.{4}$)").exec(t.toString("hex"))||[];if("9000"!==r)throw new Error(`An error happened while generating the challenge. Status code: ${r}`);return`0x${e}`}).catch(t=>{throw(0,a.log)("error","couldn't request a challenge",t),t})})}starkGetPublicKey(t,r){const n=(0,f.splitPath)(t),o=e.alloc(1+4*n.length);return o[0]=n.length,n.forEach((t,e)=>{o.writeUInt32BE(t,1+4*e)}),this.transport.send(240,2,r?1:0,0,o).then(t=>t.slice(0,t.length-2))}starkSignOrder(t,r,n,o,i,s,a,l,h,c,u){const g=(0,f.maybeHexBuffer)(r),d=(0,f.maybeHexBuffer)(o),p=(0,f.splitPath)(t),S=e.alloc(1+4*p.length+20+32+20+32+4+4+8+8+4+4,0);let y=0;return S[0]=p.length,p.forEach((t,e)=>{S.writeUInt32BE(t,1+4*e)}),y=1+4*p.length,g&&g.copy(S,y),y+=20,e.from(n.toString(16).padStart(64,"0"),"hex").copy(S,y),y+=32,d&&d.copy(S,y),y+=20,e.from(i.toString(16).padStart(64,"0"),"hex").copy(S,y),y+=32,S.writeUInt32BE(s,y),y+=4,S.writeUInt32BE(a,y),y+=4,e.from(l.toString(16).padStart(16,"0"),"hex").copy(S,y),y+=8,e.from(h.toString(16).padStart(16,"0"),"hex").copy(S,y),y+=8,S.writeUInt32BE(c,y),y+=4,S.writeUInt32BE(u,y),this.transport.send(240,4,1,0,S).then(t=>({r:t.slice(1,33).toString("hex"),s:t.slice(33,65).toString("hex")}))}starkSignOrder_v2(t,r,n,o,i,s,a,l,h,c,u,g,d,S,y){const w=(0,f.maybeHexBuffer)(r),x=(0,f.maybeHexBuffer)(s);if(!(n in p))throw new Error("eth.starkSignOrderv2 invalid source quantization type="+n);if(!(a in p))throw new Error("eth.starkSignOrderv2 invalid destination quantization type="+a);const m=(0,f.splitPath)(t),P=e.alloc(1+4*m.length+1+20+32+32+1+20+32+32+4+4+8+8+4+4,0);let E=0;return P[0]=m.length,m.forEach((t,e)=>{P.writeUInt32BE(t,1+4*e)}),E=1+4*m.length,P[E]=p[n],E++,w&&w.copy(P,E),E+=20,o&&e.from(o.toString(16).padStart(64,"0"),"hex").copy(P,E),E+=32,i&&e.from(i.toString(16).padStart(64,"0"),"hex").copy(P,E),E+=32,P[E]=p[a],E++,x&&x.copy(P,E),E+=20,l&&e.from(l.toString(16).padStart(64,"0"),"hex").copy(P,E),E+=32,h&&e.from(h.toString(16).padStart(64,"0"),"hex").copy(P,E),E+=32,P.writeUInt32BE(c,E),E+=4,P.writeUInt32BE(u,E),E+=4,e.from(g.toString(16).padStart(16,"0"),"hex").copy(P,E),E+=8,e.from(d.toString(16).padStart(16,"0"),"hex").copy(P,E),E+=8,P.writeUInt32BE(S,E),E+=4,P.writeUInt32BE(y,E),this.transport.send(240,4,3,0,P).then(t=>({r:t.slice(1,33).toString("hex"),s:t.slice(33,65).toString("hex")}))}starkSignTransfer(t,r,n,o,i,s,a,l,h){const c=(0,f.maybeHexBuffer)(r),u=(0,f.hexBuffer)(o),g=(0,f.splitPath)(t),d=e.alloc(1+4*g.length+20+32+32+4+4+8+4+4,0);let p=0;return d[0]=g.length,g.forEach((t,e)=>{d.writeUInt32BE(t,1+4*e)}),p=1+4*g.length,c&&c.copy(d,p),p+=20,e.from(n.toString(16).padStart(64,"0"),"hex").copy(d,p),p+=32,u.copy(d,p),p+=32,d.writeUInt32BE(i,p),p+=4,d.writeUInt32BE(s,p),p+=4,e.from(a.toString(16).padStart(16,"0"),"hex").copy(d,p),p+=8,d.writeUInt32BE(l,p),p+=4,d.writeUInt32BE(h,p),this.transport.send(240,4,2,0,d).then(t=>({r:t.slice(1,33).toString("hex"),s:t.slice(33,65).toString("hex")}))}starkSignTransfer_v2(t,r,n,o,i,s,a,l,h,c,u,g,d){const S=(0,f.maybeHexBuffer)(r),y=(0,f.hexBuffer)(s),w=(0,f.maybeHexBuffer)(g);if(!(n in p))throw new Error("eth.starkSignTransferv2 invalid quantization type="+n);const x=(0,f.splitPath)(t),m=e.alloc(1+4*x.length+1+20+32+32+32+4+4+8+4+4+(w?52:0),0);let P=0;return m[0]=x.length,x.forEach((t,e)=>{m.writeUInt32BE(t,1+4*e)}),P=1+4*x.length,m[P]=p[n],P++,S&&S.copy(m,P),P+=20,o&&e.from(o.toString(16).padStart(64,"0"),"hex").copy(m,P),P+=32,i&&e.from(i.toString(16).padStart(64,"0"),"hex").copy(m,P),P+=32,y.copy(m,P),P+=32,m.writeUInt32BE(a,P),P+=4,m.writeUInt32BE(l,P),P+=4,e.from(h.toString(16).padStart(16,"0"),"hex").copy(m,P),P+=8,m.writeUInt32BE(c,P),P+=4,m.writeUInt32BE(u,P),w&&d&&(P+=4,e.from(d.toString(16).padStart(64,"0"),"hex").copy(m,P),P+=32,w.copy(m,P)),this.transport.send(240,4,w?5:4,0,m).then(t=>({r:t.slice(1,33).toString("hex"),s:t.slice(33,65).toString("hex")}))}starkProvideQuantum(t,r){const n=(0,f.maybeHexBuffer)(t),o=e.alloc(52,0);return n&&n.copy(o,0),e.from(r.toString(16).padStart(64,"0"),"hex").copy(o,20),this.transport.send(240,8,0,0,o).then(()=>!0,t=>{if(t&&27904===t.statusCode)return!1;throw t})}starkProvideQuantum_v2(t,r,n,o){const i=(0,f.maybeHexBuffer)(t);if(!(r in p))throw new Error("eth.starkProvideQuantumV2 invalid quantization type="+r);const s=e.alloc(84,0);let a=0;return i&&i.copy(s,a),a+=20,n&&e.from(n.toString(16).padStart(64,"0"),"hex").copy(s,a),a+=32,o&&e.from(o.toString(16).padStart(64,"0"),"hex").copy(s,a),this.transport.send(240,8,p[r],0,s).then(()=>!0,t=>{if(t&&27904===t.statusCode)return!1;throw t})}starkUnsafeSign(t,r){const n=(0,f.hexBuffer)(r),o=(0,f.splitPath)(t),i=e.alloc(1+4*o.length+32);let s=0;return i[0]=o.length,o.forEach((t,e)=>{i.writeUInt32BE(t,1+4*e)}),s=1+4*o.length,n.copy(i,s),this.transport.send(240,10,0,0,i).then(t=>({r:t.slice(1,33).toString("hex"),s:t.slice(33,65).toString("hex")}))}eth2GetPublicKey(t,r){const n=(0,f.splitPath)(t),o=e.alloc(1+4*n.length);return o[0]=n.length,n.forEach((t,e)=>{o.writeUInt32BE(t,1+4*e)}),this.transport.send(224,14,r?1:0,0,o).then(t=>({publicKey:t.slice(0,-2).toString("hex")}))}eth2SetWithdrawalIndex(t){const r=e.alloc(4,0);return r.writeUInt32BE(t,0),this.transport.send(224,16,0,0,r).then(()=>!0,t=>{if(t&&27904===t.statusCode)return!1;throw t})}getEIP1024PublicEncryptionKey(t,r){const n=(0,f.splitPath)(t),o=e.alloc(1+4*n.length);return o[0]=n.length,n.forEach((t,e)=>{o.writeUInt32BE(t,1+4*e)}),this.transport.send(224,24,r?1:0,0,o).then(t=>({publicKey:t.slice(0,-2).toString("hex")}))}getEIP1024SharedSecret(t,r,n){const o=(0,f.splitPath)(t),i=(0,f.hexBuffer)(r),s=e.alloc(1+4*o.length+32);let a=0;return s[0]=o.length,o.forEach((t,e)=>{s.writeUInt32BE(t,1+4*e)}),a=1+4*o.length,i.copy(s,a),this.transport.send(224,24,n?1:0,1,s).then(t=>({sharedSecret:t.slice(0,-2).toString("hex")}))}provideERC20TokenInformation(t){const r=e.from(t,"hex");return this.transport.send(224,10,0,0,r).then(()=>!0,t=>{if(t&&27904===t.statusCode)return!1;throw t})}setExternalPlugin(t,r){const n=e.from(t,"hex"),o=e.from(null!=r?r:"","hex"),i=e.concat([n,o]);return this.transport.send(224,18,0,0,i).then(()=>!0,t=>{if(t&&27264===t.statusCode)return!1;if(t&&27012===t.statusCode)return!1;if(t&&27904===t.statusCode)return!1;throw t})}setPlugin(t){const r=e.from(t,"hex");return this.transport.send(224,22,0,0,r).then(()=>!0,t=>{if(t&&27264===t.statusCode)return!1;if(t&&27012===t.statusCode)return!1;if(t&&27904===t.statusCode)return!1;throw t})}provideNFTInformation(t){const r=e.from(t,"hex");return this.transport.send(224,20,0,0,r).then(()=>!0,t=>{if(t&&27904===t.statusCode)throw new c.EthAppNftNotSupported;throw t})}provideDomainName(t){return i(this,void 0,void 0,function*(){let r;!function(t){t[t.CLA=224]="CLA",t[t.INS=34]="INS",t[t.P1_FIRST_CHUNK=1]="P1_FIRST_CHUNK",t[t.P1_FOLLOWING_CHUNK=0]="P1_FOLLOWING_CHUNK",t[t.P2=0]="P2"}(r||(r={}));const n=e.from(t,"hex"),o=e.concat([e.from((0,f.intAsHexBytes)(n.length,2),"hex"),n]),i=new Array(Math.ceil(o.length/256)).fill(null).map((t,e)=>o.slice(255*e,255*(e+1)));for(const t of i){const e=t===i[0];yield this.transport.send(r.CLA,r.INS,e?r.P1_FIRST_CHUNK:r.P1_FOLLOWING_CHUNK,r.P2,t)}return!0})}}}).call(this)}).call(this,t("buffer").Buffer)}}},{package:"@ledgerhq/hw-app-eth",file:"node_modules/@ledgerhq/hw-app-eth/lib/Eth.js"}]],[],{});